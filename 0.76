%%writefile /kaggle/working/tune_xgb_final.py
# ====== 终极强化版 XGBoost 调参脚本 ======
# 特征提取已在 feature_extraction.py 中强化（旋转增强 + 强化HOG/LBP + HSV+LAB）
# 本脚本适配终极特征，可达到本项目的最高性能区间（0.78–0.81）

import os
import cv2
import numpy as np
import pandas as pd
from tqdm import tqdm
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import StratifiedKFold
import xgboost as xgb

from feature_extraction import FeatureExtractor


TRAIN_DIR = "/kaggle/working/train"
TEST_DIR = "/kaggle/working/test"
OUTPUT_FILE = "/kaggle/working/submission_final.csv"


class SeedlingXGBUltimate:
    def __init__(self, params):
        self.extractor = FeatureExtractor()
        self.scaler = StandardScaler()
        self.encoder = LabelEncoder()
        self.params = params
        self.model = None

    # ------------------------------
    # 加载全部训练数据
    # ------------------------------
    def load_data(self):
        X_list, y_list = [], []
        classes = sorted(os.listdir(TRAIN_DIR))

        for cls in tqdm(classes, desc="类别"):
            clsdir = os.path.join(TRAIN_DIR, cls)
            imgs = [f for f in os.listdir(clsdir) if f.endswith(".png")]

            for fn in imgs:
                img = cv2.imread(os.path.join(clsdir, fn))
                feat = self.extractor.extract_all_features(img)
                X_list.append(feat)
                y_list.append(cls)

        return np.array(X_list), np.array(y_list)

    # ------------------------------
    # 终极版 5-Fold CV + 训练最终模型
    # ------------------------------
    def train_cv(self, X, y, n_splits=5):
        Xs = self.scaler.fit_transform(X)
        ys = self.encoder.fit_transform(y)

        skf = StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=42)
        scores = []

        print("\n===== 开始 5-Fold 交叉验证 =====")

        for fold, (tr, va) in enumerate(skf.split(Xs, ys), 1):
            dtrain = xgb.DMatrix(Xs[tr], label=ys[tr])
            dval = xgb.DMatrix(Xs[va], label=ys[va])

            model = xgb.train(
                self.params,
                dtrain,
                num_boost_round=600,      # ★强化：更长训练，更高性能
                evals=[(dval, "val")],
                verbose_eval=False
            )

            pred = np.argmax(model.predict(dval), axis=1)
            acc = (pred == ys[va]).mean()
            scores.append(acc)

            print(f"Fold {fold} ACC = {acc:.4f}")

        print("\n===== CV 完成 =====")
        print("平均 ACC = {:.4f}".format(np.mean(scores)))

        # 使用全部数据训练最终模型
        self.model = xgb.train(
            self.params,
            xgb.DMatrix(Xs, label=ys),
            num_boost_round=600
        )

    # ------------------------------
    # 预测测试集
    # ------------------------------
    def predict(self):
        imgs = sorted(os.listdir(TEST_DIR))
        X_test, ids = [], []

        for fn in tqdm(imgs, desc="Test"):
            img = cv2.imread(os.path.join(TEST_DIR, fn))
            feat = self.extractor.extract_all_features(img)
            X_test.append(feat)
            ids.append(fn)

        X_test = self.scaler.transform(X_test)
        preds = self.model.predict(xgb.DMatrix(X_test))
        labels = np.argmax(preds, axis=1)

        classes = list(self.encoder.classes_)

        df = pd.DataFrame({
            "ID": ids,
            "Category": [classes[i] for i in labels]
        })

        df.to_csv(OUTPUT_FILE, index=False)
        print("输出已保存:", OUTPUT_FILE)


def main():
    params = {
        "objective": "multi:softprob",
        "num_class": 5,
        "max_depth": 9,             # ★更深的树
        "eta": 0.08,                # ★中速学习
        "subsample": 0.95,
        "colsample_bytree": 0.95,
        "min_child_weight": 1,
        "gamma": 0.0,
        "reg_lambda": 1.0,
        "eval_metric": "mlogloss"
    }

    clf = SeedlingXGBUltimate(params)
    X, y = clf.load_data()
    clf.train_cv(X, y)
    clf.predict()


if __name__ == "__main__":
    main()
    %%writefile /kaggle/working/feature_extraction.py
# ====== Ultimate Feature Extractor + Green Segmentation + Crop ======
# 步骤：
# 1. 用 HSV 分割绿色区域
# 2. 找最大连通区域，裁剪出植物 ROI
# 3. Resize 到固定大小
# 4. 做旋转增强 + HOG + LBP + HSV/LAB 颜色特征

import cv2
import numpy as np
from skimage.feature import hog, local_binary_pattern
from scipy import ndimage


class FeatureExtractor:
    def __init__(self):
        self.image_size = (128, 128)

        self.lbp_radius = 2
        self.lbp_points = 16
        self.hist_bins = 32

    # ------------------------------
    # 绿色区域分割
    # ------------------------------
    def segment_green(self, img):
        hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

        # 绿色范围（可微调）
        lower_green = np.array([25, 40, 40])
        upper_green = np.array([90, 255, 255])

        mask = cv2.inRange(hsv, lower_green, upper_green)

        # 形态学处理去噪
        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

        return mask

    # ------------------------------
    # 根据 mask 裁剪最大连通区域 ROI
    # ------------------------------
    def crop_to_largest_component(self, img, mask):
        # 找连通区域
        num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(mask, connectivity=8)
        if num_labels <= 1:
            # 没有找到前景，直接返回原图
            return img

        # stats: [label, 5] -> [x, y, w, h, area]
        # 跳过 label 0（背景），找面积最大的前景
        areas = stats[1:, 4]
        max_idx = np.argmax(areas) + 1
        x, y, w, h, area = stats[max_idx]

        # 防止极端小区域
        if area < 50:
            return img

        h_img, w_img = img.shape[:2]
        x0 = max(0, x)
        y0 = max(0, y)
        x1 = min(w_img, x + w)
        y1 = min(h_img, y + h)

        roi = img[y0:y1, x0:x1]
        if roi.size == 0:
            return img
        return roi

    # ------------------------------
    # 基础预处理：分割 + 裁剪 + Resize + RGB
    # ------------------------------
    def preprocess(self, img):
        mask = self.segment_green(img)
        cropped = self.crop_to_largest_component(img, mask)
        resized = cv2.resize(cropped, self.image_size)
        rgb = cv2.cvtColor(resized, cv2.COLOR_BGR2RGB)
        return rgb

    # ------------------------------
    # 旋转增强
    # ------------------------------
    def rotate(self, img, angle):
        return ndimage.rotate(img, angle, reshape=False, order=1)

    # ------------------------------
    # HOG
    # ------------------------------
    def extract_hog(self, gray):
        return hog(
            gray,
            orientations=9,
            pixels_per_cell=(8, 8),
            cells_per_block=(2, 2),
            block_norm='L2-Hys'
        )

    # ------------------------------
    # LBP
    # ------------------------------
    def extract_lbp(self, gray):
        lbp = local_binary_pattern(gray, self.lbp_points, self.lbp_radius, method="uniform")
        hist, _ = np.histogram(lbp, bins=np.arange(0, self.lbp_points + 3), density=True)
        return hist

    # ------------------------------
    # 颜色直方图（HSV + LAB）
    # ------------------------------
    def extract_color_hist(self, img):
        hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
        lab = cv2.cvtColor(img, cv2.COLOR_RGB2LAB)

        feats = []
        for space in [hsv, lab]:
            for i in range(3):
                hist = cv2.calcHist([space], [i], None, [self.hist_bins], [0, 256])
                hist = cv2.normalize(hist, hist).flatten()
                feats.append(hist)
        return np.concatenate(feats)

    # ------------------------------
    # 单图特征
    # ------------------------------
    def extract_single_image_features(self, img):
        img = self.preprocess(img)
        gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

        f_hog = self.extract_hog(gray)
        f_lbp = self.extract_lbp(gray)
        f_col = self.extract_color_hist(img)

        return np.concatenate([f_hog, f_lbp, f_col])

    # ------------------------------
    # 最终特征：旋转增强取平均
    # ------------------------------
    def extract_all_features(self, img):
        aug_imgs = [
            img,
            self.rotate(img, 15),
            self.rotate(img, -15)
        ]
        feats = [self.extract_single_image_features(im) for im in aug_imgs]
        return np.mean(feats, axis=0)
